# pretty ü™∂

a simple pretty printer for arbitrary data structures in [Zig](https://ziglang.org/)‚ö°Ô∏è

designed to inspect deeply-nested and recursive tree structures.

current version: [v0.8.2](https://github.com/timfayz/pretty/tags)

## demo

simplified version of [`src/demo.zig`](https://github.com/timfayz/pretty/blob/main/src/demo.zig):

```zig
// main.zig
const std = @import("std");
const pretty = @import("pretty.zig");
const alloc = std.heap.page_allocator;

pub fn main() !void {
    const array = [3]u8{ 4, 5, 6 };

    // method 1: print with default options
    try pretty.print(alloc, array, .{});

    // method 2: customize your print
    try pretty.print(alloc, array, .{
        .arr_show_item_idx = false,
        .arr_max_len = 2,
    });

    // method 3: don't print, get a string!
    var out = try pretty.dump(alloc, array, .{});
    defer alloc.free(out);
    std.debug.print("{s}..\n", .{out[0..5]});
}
```

output:

```
$ zig run main.zig
[3]u8
  0: 4
  1: 5
  2: 6

[3]u8
  4
  5

[3]u8..
```

## installation

to use pretty:

- `git clone https://github.com/timfayz/pretty`, `cd pretty` and `zig build run`, or
- [download latest version](https://github.com/timfayz/pretty/blob/main/src/pretty.zig) of `pretty.zig` and `@import` it directly inside your project, or
- use [zig build system](https://ziglang.org/learn/build-system/) and `build.zig.zon` (highly undocumented):

```bash
$ cd your_project
$ ls
src/
build.zig     # should be present (otherwise use `zig init` to generate it)
build.zig.zon # optional (otherwise will be generated by the next command)
$ zig fetch --save https://github.com/timfayz/pretty/archive/v0.8.2.tar.gz
$ cat build.zig.zon
..
  .pretty = .{
      .url = "https://github.com/timfayz/pretty/archive/v0.8.2.tar.gz",
      .hash = "..long_hash..",
  },
..
```

edit `build.zig`:

```zig
// find this:
const exe = b.addExecutable(.{
    .name = "your_app",
    .root_source_file = .{ .path = "src/main.zig" },
    .target = target,
    .optimize = optimize,
});

// add the following:
const pretty = b.dependency("pretty", .{ .target = target, .optimize = optimize });
exe.root_module.addImport("pretty", pretty.module("pretty"));
..
```

done, build or run your project:

```
$ zig build # or zig build run
```

## api

pretty offers three main functions:

1. `pretty.print` ‚Äì generates a string and prints it to stdout.
1. `pretty.dump` ‚Äì generates a string and returns it as a `[]u8` slice.
1. `pretty.dumpAsList` ‚Äì generates a string and returns it as `std.ArrayList` interface.

## options

pretty output can be customized with the following options (default values in the option code):

#### generic printing options

- limit the depth:

```
max_depth: u8 = 10
```

- specify depths to include or exclude from the output:

```
filter_depths: Filter(usize) = .{ .exclude = &.{} }
```

- indentation size for depth levels:

```
tab_size: u8 = 2
```

- add an empty line at the end of the output (to separate several prints):

```
empty_line_at_end: bool = true
```

- format for the sign used to indicate skipping:

```
skip_sign: []const u8 = ".."
```

#### generic type printing options

- display type tags:

```
show_type_tags: bool = false
```

- display type names:

```
show_type_names: bool = true
```

- limit the length of type names:

```
type_name_max_len: usize = 60
```

- fold brackets in type names (with '..'):

```
type_name_fold_brackets: bool = true
```

- do not fold brackets for function signatures:

```
type_name_fold_except_fn: bool = true
```

#### generic value printing options

- display values:

```
show_vals: bool = true
```

- display empty values:

```
show_empty_vals: bool = true
```

#### pointer printing options

- follow pointers instead of printing their address:

```
ptr_deref: bool = true
```

- reduce duplicating depths when dereferencing pointers:

```
ptr_skip_dup_unfold: bool = true
```

#### optional printing options

- reduce duplicating depths when unfolding optional types:

```
optional_skip_dup_unfold: bool = true
```

#### struct printing options

- display struct fields:

```
struct_show_fields: bool = true
```

- treat empty structs as having a 'null' value:

```
struct_show_empty: bool = true
```

- limit the number of fields in the output:

```
struct_max_len: usize = 10
```

- specify field names to include or exclude from the output:

```
filter_field_names: Filter([]const u8) = .{ .exclude = &.{} }
```

- specify field types to include or exclude from the output:

```
filter_field_types: Filter(std.builtin.TypeId) = .{ .exclude = &.{} }
```

#### array and slice printing options

- limit the number of items in the output:

```
arr_max_len: usize = 20
```

- display item indices:

```
arr_show_item_idx: bool = true
```

- display values of primitive types on the same line as the index:

```
arr_inline_prim_types: bool = true
```

- specify types to treat as primitives:

```
arr_prim_types: Filter(std.builtin.TypeId) = .{ .include = &.{
    .Int,
    .ComptimeInt,
    .Float,
    .ComptimeFloat,
    .Void,
    .Bool,
} }
```

#### string printing options

- treat []u8 as "string":

```
str_is_u8: bool = true
```

- limit the length of strings:

```
str_max_len: usize = 80
```

## examples

derived from [`src/tests.zig`](https://github.com/timfayz/pretty/blob/main/src/tests.zig):

```zig
const example_1: struct {
    field1: bool = true,
    field2: u8 = 42,
    field3: f32 = 1.1,
} = .{};
```

```zig
try pretty.print(alloc, example_1, .{});
```

```
tmp.main__struct_1652
  .field1: bool
    true
  .field2: u8
    42
  .field3: f32
    1.10000002e+00
```

use options to query and "cut off" unnecessary output:

```zig
try pretty.print(alloc, example_1, .{
    .filter_depths = .{ .exclude = &.{ 0, 2 } },
});
```

```
.field1: bool
.field2: u8
.field3: f32
```

```zig
try pretty.print(alloc, example_1, .{
      .filter_depths = .{ .include = &.{2} },
});
```

```
true
42
1.10000002e+00
```

```zig
try pretty.print(alloc, example_1, .{
    .filter_depths = .{ .exclude = &.{0} },
    .filter_field_names = .{ .include = &.{"field2"} },
});
```

```
.field2: u8
  42
```

## contributing ‚ù§Ô∏è

please feel free to:

- open an issue and describe the change you'd like to see.
- fork the repository and submit your pull request.

## license

all codebase are belong to MIT.
